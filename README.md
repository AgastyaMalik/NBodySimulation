# CUDA N-Body Simulation with 3D Visualization

This repository contains a CUDA-based N-body simulation implemented in C++ to model the gravitational interactions of celestial bodies, along with a Python script for 3D visualization of the simulation results. The project demonstrates parallel computing using NVIDIA's CUDA platform to accelerate computations and Matplotlib for animated 3D trajectory plotting.

## Project Overview

The N-body simulation computes the motion of multiple bodies under mutual gravitational forces using the leapfrog integration method. The C++ code (`nbody.cu`) leverages CUDA to parallelize force calculations on a GPU, significantly improving performance for large systems. The simulation outputs body positions at each time step to a text file (`positions.txt`), which is then visualized as an animated 3D plot using a Python script (`plot_nbody_3d.py`).

### Motivation

I initially faced challenges with the computational power required for N-body simulations in standard C++ due to the O(n^2) complexity of force calculations. To address this, I researched parallelism and discovered NVIDIA's CUDA, which allows GPU-accelerated computing. After confirming my GPU was CUDA-capable, I implemented the simulation using CUDA to harness parallel processing. Additionally, I learned to create 3D visualizations with Matplotlib to better understand the simulation's output, overcoming my lack of prior experience with 3D plotting.

## Files in the Repository

- `nbody.cu`: C++ code with CUDA kernels for the N-body simulation. It computes forces, updates positions and velocities, and saves positions to `positions.txt`.
- `plot_nbody_3d.py`: Python script using Matplotlib to create an animated 3D plot of the body trajectories from `positions.txt`.
- `positions.txt`: Sample output file containing body positions for the test case (generated by running `nbody.cu`).

## Test Case

The simulation was tested with a two-body gravitational system to verify correctness. The test case models two equal-mass bodies orbiting their common center of mass in an elliptical orbit.

### Test Case Inputs

- **Number of bodies**: 2
- **Body 1**:
  - Mass: 1.0e30 kg
  - Position: (0, 0, 0) m
  - Velocity: (0, 0, 0) m/s
- **Body 2**:
  - Mass: 1.0e30 kg
  - Position: (1.0e11, 0, 0) m
  - Velocity: (0, 2.0e4, 0) m/s
- **Time step size (dt)**: 3600 seconds (1 hour)
- **Number of time steps**: 1500 (approximating one orbital period, ~62.5 days)

### Expected Behavior

- The bodies orbit their center of mass at (5.0e10, y_cm, 0) m, where y_cm increases linearly at 1.0e4 m/s.
- The initial separation is 1.0e11 m, and the orbit is elliptical due to the velocity being less than the circular orbit velocity (~3.655e4 m/s).
- After ~62.5 days, the bodies should be close to their initial relative positions, adjusted for center of mass motion (Δy_cm ≈ 5.4e10 m).
- The 3D visualization shows planar elliptical trajectories (z = 0), with the system drifting in the positive y-direction.

## Challenges Faced

- **Computational Power Limitations**:
  - Standard C++ implementations were too slow for large N-body systems due to the quadratic complexity of force calculations.
  - Solution: Researched parallel computing and identified CUDA as a suitable framework for GPU acceleration.

- **Learning CUDA**:
  - I had no prior experience with CUDA or GPU programming. I confirmed my GPU was CUDA-capable and learned to write CUDA kernels, manage device memory, and use shared memory for optimization.
  - Challenges included setting up the CUDA Toolkit, configuring Visual Studio for `cl.exe`, and resolving compilation errors (e.g., `nvcc` not finding `cl.exe`).

- **Correcting Simulation Errors**:
  - Initial CUDA implementation produced incorrect results due to a flawed leapfrog integration (double position updates). Debugging involved tracking the center of mass and adjusting the integration logic to split velocity and position updates.
  - Ensured numerical stability with a softening parameter (1e-9) and appropriate time step size.

- **3D Visualization**:
  - I had no experience with 3D plotting. I learned to use Matplotlib’s `mpl_toolkits.mplot3d` to create animated 3D visualizations, starting with a 2D plot and extending to 3D for full compatibility with the simulation’s capabilities.

## How to Run the Code

### Prerequisites

- **C++ with CUDA**:
  - NVIDIA GPU with CUDA support
  - CUDA Toolkit (e.g., v12.6)
  - Visual Studio 2022 with C++ Desktop Development workload
  - `nvcc` and `cl.exe` in PATH
- **Python**:
  - Python 3.9 or later
  - Libraries: `numpy`, `matplotlib`
    ```bash
    pip install numpy matplotlib
    ```

### Steps

1. **Compile and Run the C++ Code**:
   - Open Developer Command Prompt for VS 2022.
   - Navigate to the repository directory:
     ```cmd
     cd path\to\repository
     ```
   - Compile:
     ```cmd
     nvcc -o nbody nbody.cu -arch=sm_75
     ```
     Adjust `-arch` based on your GPU (e.g., `sm_80` for Ampere GPUs).
   - Run:
     ```cmd
     .\nbody
     ```
   - Enter the test case inputs:
     ```
     Number of bodies: 2
     Body 1: Mass = 1.0e30, Position = 0 0 0, Velocity = 0 0 0
     Body 2: Mass = 1.0e30, Position = 1.0e11 0 0, Velocity = 0 2.0e4 0
     Time step size (dt): 3600
     Number of time steps: 1500
     ```
   - This generates `positions.txt`.

2. **Run the Python Visualization**:
   - Ensure `positions.txt` is in the same directory as `plot_nbody_3d.py`.
   - Run:
     ```cmd
     python plot_nbody_3d.py
     ```
   - An animated 3D plot will display the trajectories of the bodies.

### Output

- **Console Output**: Center of mass positions and final body positions are printed to the console.
- **positions.txt**: Contains x, y, z coordinates for each body at each time step.
- **3D Visualization**: Shows elliptical orbits in the x-y plane (z = 0), with the system drifting along the y-axis. The plot is interactive, allowing rotation to view the trajectories.

## Future Improvements

- **Circular Orbit Test**: Use a velocity of 3.655e4 m/s for Body 2 to test a circular orbit, verifying exact position return after one period.
- **3D Motion**: Add z-velocity (e.g., 1.0e4 m/s for Body 2) to test full 3D orbits.
- **Performance Optimization**: Adjust `threadsPerBlock` or implement a Barnes-Hut algorithm for larger systems.
- **Video Output**: Save the animation as an MP4 using Matplotlib’s `animation.writers`.
- **Real-Time Visualization**: Explore OpenGL or SFML for real-time rendering in C++.

## Acknowledgments

- Thanks to NVIDIA’s CUDA documentation for learning GPU programming.
- Matplotlib tutorials helped with 3D visualization.
- Guidance from online resources and debugging support improved the simulation’s accuracy.
